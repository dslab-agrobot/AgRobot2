# 6.00Listen.py文档

## 概述

本 ROS 节点用于监听 Modbus 设备的状态并执行相应的操作。它通过 Modbus 协议与设备通信，并实现了以下功能：
- 监听各通道的速度相关值。
- 监控两个 X 轴的位置是否一致，并在不一致时采取应急措施。

## 导入的模块

- rospy：ROS Python 客户端库。[rospy的介绍](6.01rospy的介绍)
- wrapper_modbus.d12_modbus_client：自定义的 D12 Modbus 客户端。[wrapper_modbus.d12_modbus_client的介绍](6.02wrapper_modbus.d12_modbus_client的介绍)
- wrapper_modbus.d12_controller_mapping：包含设备控制映射。[wrapper_modbus.d12_controller_mapping的介绍](6.03wrapper_modbus.d12_controller_mapping的介绍)

## 主要函数和方法

- **SpeedandMs(ch_x:list)**：

  - 获取通道的速度和微步参数[微步参数的介绍](6.04微步参数的介绍)，并打印输出。

  - 参数：
    - `ch_x (list)`：通道参数列表，包括寄存器地址等。

- **Monitor_X_Axis_Position(result)**：
  - 监控两个 X 轴的位置是否一致，并在不一致时采取应急措施。
  - 参数：
    - `result (list)`：从 Modbus 设备读取的状态信息。

- **主程序：\_\_main\_\_ 部分**

  - 初始化 ROS 节点，命名为 "Listen"：

    使用 `rospy.init_node("Listen")` 初始化了一个 ROS 节点，命名为 "Listen"。

  - 创建 Modbus 客户端：

    使用 `D12ModbusClient` 类创建了一个 Modbus 客户端对象 `client`，并传入了 Modbus 设备的 IP 地址。

  - 获取各通道的速度相关值并打印输出：

     使用 `SpeedandMs(ch_x)` 函数，对每个通道的速度和微步参数进行获取，并使用 `rospy.loginfo()` 打印输出。

  - 进入循环，每秒监听 Modbus 设备的状态并监控 X 轴位置：

    1. 使用 `while not rospy.is_shutdown()` 进入一个无限循环；
    2. 在每个循环中，我们使用 `rospy.sleep(1)` 暂停一秒钟；
    3. 调用 `client.multiAxis_StateRead()` 方法从 Modbus 设备读取状态信息，并将结果存储在 `result` 变量中；
    4. 接着调用 `Monitor_X_Axis_Position(result)` 函数，监控两个 X 轴的位置是否一致，如果发现不一致，则执行应急措施。

## 变量和常量 

- `host (str)`： Modbus 设备的 IP 地址。 
- `address_read_start (int)`：从 Modbus 设备读取状态信息的起始地址。  
- `num_registers (int) `：从 Modbus 设备读取的寄存器数量。